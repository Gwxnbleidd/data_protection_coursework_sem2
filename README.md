# Система электронной подписи на основе протокола Фиата-Шамира

## Описание проекта

Данный проект представляет собой реализацию системы электронной подписи, основанной на протоколе Фиата-Шамира. Система позволяет создавать цифровые подписи для файлов, проверять их подлинность и обеспечивать целостность данных.

## Автор

**Гайчуков Дмитрий**  
Группа: А-13-21  
Курсовая работа по дисциплине "Криптографические методы защиты информации"

## Особенности реализации

- **Протокол Фиата-Шамира**: Использование криптографического протокола идентификации для создания цифровых подписей
- **Графический интерфейс**: Удобный GUI на базе Tkinter для работы с системой
- **Безопасность**: Защита закрытых ключей паролем с использованием SHA-256
- **Целостность файлов**: Подпись основана на метаданных файла (размер, права доступа, inode и т.д.)
- **Гибкая генерация ключей**: Автоматическая генерация простых чисел p и q с длиной модуля 512-1024 бит

## Архитектура проекта

```
data_protection_coursework_sem2/
├── core/                           # Основная логика системы
│   ├── fiat_shamir_signature.py   # Реализация протокола Фиата-Шамира
│   ├── electronic_signature.py    # Высокоуровневый API для работы с подписями
│   ├── file_info.py              # Сбор метаданных файлов
│   └── utils.py                  # Вспомогательные криптографические функции
├── gui/                           # Графический интерфейс
│   ├── main_window.py            # Главное окно приложения
│   └── choice_key_window.py      # Окно выбора ключей
├── main.py                       # Точка входа в приложение
└── requirements.txt              # Зависимости проекта
```

## Математические основы

### Протокол Фиата-Шамира

1. **Генерация ключей**:
   - Выбираются два простых числа p и q
   - Вычисляется n = p × q
   - Генерируются секретные значения s₁, s₂, ..., sₜ
   - Вычисляются открытые значения vᵢ = sᵢ⁻² (mod n)

2. **Процесс подписания**:
   - Выбираются случайные значения r₁, r₂, ..., rₜ
   - Вычисляются xᵢ = rᵢ² (mod n)
   - Создается хеш H(message, x₁, x₂, ..., xₜ)
   - Из хеша извлекаются биты bᵢⱼ
   - Вычисляются yᵢ = rᵢ × ∏(sⱼ^bᵢⱼ) (mod n)

3. **Проверка подписи**:
   - Вычисляются zᵢ = yᵢ² × ∏(vⱼ^bᵢⱼ) (mod n)
   - Создается хеш H(message, z₁, z₂, ..., zₜ)
   - Проверяется совпадение битов подписи

## Установка и запуск

### Требования

- Python 3.8+
- Tkinter (обычно входит в стандартную поставку Python)

### Установка зависимостей

```bash
pip install -r requirements.txt
```

### Запуск приложения

```bash
python main.py
```

## Использование

### 1. Создание новых ключей

1. Запустите приложение
2. Нажмите "Подписать документ"
3. Выберите "Создать новые ключи"
4. Укажите папку для сохранения ключей
5. Введите пароль для защиты закрытого ключа
6. Выберите файл для подписания
7. Введите имя подписывающего
8. Укажите путь для сохранения подписи

### 2. Использование существующих ключей

1. Запустите приложение
2. Нажмите "Подписать документ"
3. Выберите "Использовать существующие ключи"
4. Укажите папку с ключами
5. Введите пароль для закрытого ключа
6. Выберите файл для подписания
7. Введите имя подписывающего
8. Укажите путь для сохранения подписи

### 3. Проверка подписи

1. Запустите приложение
2. Нажмите "Проверить документ"
3. Выберите файл для проверки
4. Укажите файл с подписью
5. Выберите публичный ключ
6. Получите результат проверки

## Структура файлов

### Ключи
- `public_key.pk` - Публичный ключ (n, v₁, v₂, ..., vₜ)
- `private_key.sk` - Закрытый ключ, защищенный паролем (n, s₁, s₂, ..., sₜ)

### Подпись
- Файл подписи содержит:
  - Имя подписывающего
  - Матрицу битов bᵢⱼ
  - Значения yᵢ

## Безопасность

- **Длина ключа**: 512-1024 бит (настраивается)
- **Защита ключей**: Закрытые ключи защищены паролем с использованием SHA-256
- **Целостность**: Подпись основана на метаданных файла, что обеспечивает обнаружение изменений
- **Криптографическая стойкость**: Использование проверенных математических алгоритмов

## Технические детали

### Алгоритм генерации простых чисел
- Используется тест Миллера-Рабина для проверки простоты
- Автоматический подбор p и q для получения n нужной длины
- Обеспечение примерно равного размера p и q

### Хеширование
- Используется SHA-256 для создания хешей
- Хеш включает содержимое сообщения и все значения xᵢ или zᵢ

### Формат данных
- Ключи и подписи сериализуются с помощью pickle
- Метаданные файлов собираются через os.stat()

## Примеры использования

## Ограничения

- Подпись основана на метаданных файла, а не на содержимом
- Изменение прав доступа или перемещение файла сделает подпись недействительной
- Требуется Python 3.8+ для корректной работы

## Лицензия

Проект создан в учебных целях для курсовой работы по криптографии.

